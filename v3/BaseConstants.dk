Set : Type.
Prop : Type.

Elem : Set -> Type.
Proof : Prop -> Type.

false : Prop.
and : Prop -> Prop -> Prop.
or : Prop -> Prop -> Prop.
if : Prop -> Prop -> Prop.
forall : (A : Set) -> (Elem A -> Prop) -> Prop.
exists : (A : Set) -> (Elem A -> Prop) -> Prop.

def not : Prop -> Prop := A => if A false.
def iff : Prop -> Prop -> Prop := A => B => and (if A B) (if B A).

Nat : Set.

zero : Elem Nat.
succ : Elem Nat -> Elem Nat.

Even : Elem Nat -> Prop.
def Odd : Elem Nat -> Prop := n => not (Even n).

Eq : Elem Nat -> Elem Nat -> Prop.

plus : Elem Nat -> Elem Nat -> Elem Nat.

times : Elem Nat -> Elem Nat -> Elem Nat.

minus : Elem Nat -> Elem Nat -> Elem Nat.

def one : Elem Nat := succ zero.
def two : Elem Nat := succ one.

Lt : Elem Nat -> Elem Nat -> Prop.

def Div : Elem Nat -> Elem Nat -> Prop := n => m => exists Nat (k => EqNat n (times k m)). 

def Prime : Elem Nat -> Prop := n => not (exists Nat (m => and (Lt one m) (and (Lt m n) (Div n m)))).

Int : Set.

positive : Elem Int -> Set.
negative : Elem Int -> Set.

Rat : Set.
Real : Set.
Complex : Set.

Function : Set -> Set -> Set.
Union : Set -> Set -> Set.
Intersection : Set -> Set -> Set.
Complement : Set -> Set.

suchthat : (A : Set) -> (Elem A -> Prop) -> Set.

