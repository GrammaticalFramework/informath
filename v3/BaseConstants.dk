Set : Type.
Prop : Type.

(; ignored in Dedukti2Core ;) 
Elem : Set -> Type.
Proof : Prop -> Type.

(; logical operators, hard-coded in MathCore ;)
false : Prop.
and : (A : Prop) -> (B : Prop) -> Prop.
or : (A : Prop) -> (B : Prop) -> Prop.
if : Prop -> Prop -> Prop.
forall : (A : Set) -> (Elem A -> Prop) -> Prop.
exists : (A : Set) -> (Elem A -> Prop) -> Prop.

def not : Prop -> Prop := A => if A false.
def iff : Prop -> Prop -> Prop := A => B => and (if A B) (if B A).

(; number domains, meant to be increasing subsets of Complex ;)
Dig : Set.
Nat : Set.
Int : Set.
Rat : Set.
Real : Set.
Complex : Set.

(; digits ;)
0 : Elem Dig.
1 : Elem Dig.
2 : Elem Dig.
3 : Elem Dig.
4 : Elem Dig.
5 : Elem Dig.
6 : Elem Dig.
7 : Elem Dig.
8 : Elem Dig.
9 : Elem Dig.

(; slightly non-canonical representation of natural numbers in base 10 ;)
(; 123 = nn 1 (nn 2 (nd 3)) ;)
(; leading zeros should be ignored ;)
nd : Elem Dig -> Elem Nat.
nn : Elem Dig -> Elem Nat -> Elem Nat.

(; coercions to Real and Int, ignored in Dedukti2Core ;) 
nat2real : (n : Elem Nat) -> Elem Real.
int2real : Elem Int -> Elem Real.
rat2real : Elem Rat -> Elem Real.
nat2int  : Elem Nat -> Elem Int.

(; basic comparison relations ;)
Eq : (x : Elem Real) -> (y : Elem Real) -> Prop.
Lt : Elem Real -> Elem Real -> Prop.
Gt : Elem Real -> Elem Real -> Prop.
Neq : Elem Real -> Elem Real -> Prop.
Leq : Elem Real -> Elem Real -> Prop.
Geq : Elem Real -> Elem Real -> Prop.

positive : (x : Elem Real) -> Prop.
negative : Elem Real -> Prop.

(; basic arithmetic operations ;)
plus : (x : Elem Real) -> (y : Elem Real) -> Elem Real.
minus : Elem Real -> Elem Real -> Elem Real.
times : Elem Real -> Elem Real -> Elem Real.
div : Elem Real -> Elem Real -> Elem Real.
pow : Elem Real -> Elem Real -> Elem Real.

gcd : Elem Int -> Elem Int -> Elem Int.
factorial : Elem Nat -> Elem Nat.

(; predicates of integers ;)
even : Elem Int -> Prop.
def odd : Elem Int -> Prop := n => not (even n).

def divisible : Elem Int -> Elem Int -> Prop := n => m => exists Int (k => Eq (int2real n) (times (int2real k) (int2real m))). 

def prime : Elem Nat -> Prop := n => not (exists Nat (m => and (Lt (nat2real (nd 1)) (nat2real m)) (and (Lt (nat2real m) (nat2real n)) (divisible (nat2int n) (nat2int  m))))).

(; set operations ;)
function : Set -> Set -> Set.
union : Set -> Set -> Set.
intersection : Set -> Set -> Set.
difference : Set -> Set -> Set.
powerset : Set -> Set.

(; hard-coded in MathCore ;)
suchthat : (A : Set) -> (B : Elem A -> Prop) -> Set.
fst : (A : Set) -> (B : (Elem A -> Prop)) -> Elem (suchthat A B) -> Elem A.

