nat ALIAS matita Nat
Type0 ALIAS matita Set
prop ALIAS matita Prop
And ALIAS matita and
Not ALIAS matita not
eq ALIAS matita Eq 1 2
le ALIAS matita Leq
lt ALIAS matita Lt
ge ALIAS matita Geq
gt ALIAS matita Gt
Or ALIAS matita or
O ALIAS matita 0
S ALIAS matita succ
fact ALIAS matita factorial
exp ALIAS matita pow
list ALIAS matita List
mem ALIAS matita member 1 2
Term ALIAS matita Elem 1
lift COERCION matita
Univ COERCION matita

rational NEW top100 Adj rational_Adj
irrational NEW top100 Adj irrational_Adj
Polynomial NEW top100 Noun polynomial_Noun
degree NEW top100 Fun degree_Fun
isRoot NEW top100 Relnoun is_root_Relnoun
cardinality NEW top100 Fun cardinality_Fun
denumerable NEW top100 Adj denumerable_Adj
Vector NEW top100 Noun vector_Noun
length NEW top100 Oper length_Oper
perpendicular NEW top100 Compar perpendicular_Compar
resultant NEW top100 Oper resultant_Oper
square NEW top100 Oper square_Oper
legendre NEW top100 Oper legendre_symbol_Oper

#LIN Eng rational_Adj = mkAdj "rational"
#LIN Fre rational_Adj = mkAdj "rationnel"
#LIN Swe rational_Adj = mkAdj "rationell"

#LIN Eng irrational_Adj = mkAdj "irrational"
#LIN Fre irrational_Adj = mkAdj "irrationnel"
#LIN Swe irrational_Adj = mkAdj "irrationell"

#LIN Eng polynomial_Noun = mkNoun "polynomial"
#LIN Fre polynomial_Noun = mkNoun (mkN "polynôme" masculine)
#LIN Swe polynomial_Noun = mkNoun (mkN "polynom" "polynom")

#LIN Eng degree_Fun = mkFun "degree"
#LIN Fre degree_Fun = mkFun (mkN "degré" masculine)
#LIN Swe degree_Fun = mkFun (mkN "grad" "grader")

#LIN Eng is_root_Relnoun = mkN2 (mkN "root")
#LIN Fre is_root_Relnoun = mkN2 (mkN "racine") genitive
#LIN Swe is_root_Relnoun = mkN2 (mkN "rot" "rötter")

#LIN Eng cardinality_Fun = mkFun "cardinality"
#LIN Fre cardinality_Fun = mkFun "cardinalité"
#LIN Swe cardinality_Fun = mkFun (mkN "kardinalitet" "kardinaliteter")

#LIN Eng denumerable_Adj = mkAdj "denumerable"
#LIN Fre denumerable_Adj = mkAdj "dénombrable"
#LIN Swe denumerable_Adj = mkAdj "upräknelig"

#LIN Eng vector_Noun = mkNoun "vector"
#LIN Fre vector_Noun = mkNoun "vecteur"
#LIN Swe vector_Noun = mkNoun (mkN "vektor" "vektorer")

#LIN Eng length_Oper = mkOper L.length_Oper "length"
#LIN Fre length_Oper = mkOper L.length_Oper "norme"
#LIN Swe length_Oper = mkOper L.length_Oper (mkN "norm" "normer")

#LIN Eng perpendicular_Compar = mkCompar L.perpendicular_Compar "perpendicular" "to"
#LIN Fre perpendicular_Compar = mkCompar L.perpendicular_Compar (mkA "perpendiculaire") dative
#LIN Swe perpendicular_Compar = mkCompar L.perpendicular_Compar "vinkelrät" "mot"

#LIN Eng resultant_Oper = mkOper L.plus_Oper "sum"
#LIN Fre resultant_Oper = mkOper L.plus_Oper (mkN "addition")
#LIN Swe resultant_Oper = mkOper L.plus_Oper (mkN "resultant" "resultanter")

#LIN Eng square_Oper = mkOper L.square_Oper "square"
#LIN Fre square_Oper = mkOper L.square_Oper (mkN "carré" masculine)
#LIN Swe square_Oper = mkOper L.square_Oper (mkN "kvadrat" "kvadrater")

#LIN Eng legendre_symbol_Oper = mkOper L.legendre_symbol_Oper "Legendre symbol"
#LIN Fre legendre_symbol_Oper = mkOper L.legendre_symbol_Oper (mkCN (mkN "symbole" masculine) (SyntaxFre.mkAdv genitive (mkNP (mkPN "Legendre"))))
#LIN Swe legendre_symbol_Oper = mkOper L.legendre_symbol_Oper (mkN "Legendresymbol" "Legendresymboler")

pi NEW top100 Const pi_Const
#LIN Eng pi_Const = mkConst "\\pi" (mkNP the_Det (mkCN (mkN "number") (symb "\\(\\pi\\)")))
#LIN Fre pi_Const = mkConst "\\pi" (mkNP the_Det (mkCN nombre_N (symb "\\(\\pi\\)")))
#LIN Swe pi_Const = mkConst "\\pi" (mkNP the_Det (mkCN tal_N (symb "\\(\\pi\\)")))

Circle NEW top100 Noun circle_Noun
#LIN Eng circle_Noun = mkNoun "circle"
#LIN Fre circle_Noun = mkNoun (mkN "cercle" masculine)
#LIN Swe circle_Noun = mkNoun (mkN "cirkel" "cirklar")

radius NEW top100 Fun radius_Fun
#LIN Eng radius_Fun = mkFun "radius"
#LIN Fre radius_Fun = mkFun "rayon"
#LIN Swe radius_Fun = mkFun "radie"

area NEW top100 Fun area_Fun
#LIN Eng area_Fun = mkFun "area"
#LIN Fre area_Fun = mkFun "aire"
#LIN Swe area_Fun = mkFun "area"



fun ALIAS hol function
el ALIAS hol Elem
prf ALIAS hol Proof
bool ALIAS hol Prop
{|ε|} ALIAS hol element
{|¬|} ALIAS hol not
{|⊥|} ALIAS hol false
{|∨|} ALIAS hol or
{|∃|} ALIAS hol exists
{|∀|} ALIAS hol forall
{|⇒|} ALIAS hol if
{|∧|} ALIAS hol and

