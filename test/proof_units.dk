(;
Prop : Type.
Set : Type.
;)
Label : Type.
Unit : Type.

elemAssumption : (A : Set) -> (a : Elem A) -> Unit.
propAssumption : (A : Prop) -> Unit.

propConclusion : (A : Prop) -> Unit.
sinceConclusion : (A : Prop) -> (B : Prop) -> Unit.
labelConclusion : (a : Label) -> Unit.
propLabelConclusion : (A : Prop) -> (a : Label) -> Unit.
followsPropConclusion : (A : Prop) -> Unit.
obviousConclusion : Unit.

firstVerifyGoal  : (A : Prop) -> Unit.
enoughGoal : (A : Prop) -> Unit.
sinceGoal : (A : Prop) -> (B : Prop) -> Unit.
caseGoal : (A : Prop) -> (B : Prop) -> Unit.

def p1 : Unit := firstVerifyGoal (odd n).

def p2 : Unit := enoughGoal (even n).

def p3 : Unit := sinceGoal (even 0) (odd 0).


(;
---- bug to be fixed: logically complex propositions not allowed
---- 
def p1 : Unit := firstVerifyGoal (forall Nat (n => if (even n) (not (odd n)))).
def p2 : Unit := enoughGoal (forall Nat (n => not (and (even n) (odd n)))).
def p3 : Unit := sinceGoal (not (and (even 0) (odd 0))) (not (odd 0)).
;)

def p4 : Unit := elemAssumption Nat 0.
def p5 : Unit := caseGoal (even 0) (odd 0).
def p6 : Unit := propAssumption (even (plus 0 1)).

def p7 : Unit := propConclusion (even (plus 0 2)).
def p8 : Unit := sinceConclusion (even (plus 0 2)) (odd (plus 0 3)).

def p9 : Unit := followsPropConclusion (even (plus 0 4)).
def p10 : Unit := obviousConclusion.


